{
  "stats": {
    "suites": 2,
    "tests": 92,
    "passes": 92,
    "pending": 0,
    "failures": 0,
    "start": "2020-05-07T21:04:40.262Z",
    "end": "2020-05-07T21:04:40.821Z",
    "duration": 559,
    "testsRegistered": 92,
    "passPercent": 100,
    "pendingPercent": 0,
    "other": 0,
    "hasOther": false,
    "skipped": 0,
    "hasSkipped": false,
    "passPercentClass": "success",
    "pendingPercentClass": "danger"
  },
  "suites": {
    "uuid": "95916d61-3133-4fd7-b565-f28164357334",
    "title": "",
    "fullFile": "",
    "file": "",
    "beforeHooks": [],
    "afterHooks": [],
    "tests": [],
    "suites": [
      {
        "uuid": "d8669b69-3f0c-4edf-990b-9346c0e8f54f",
        "title": "Parser",
        "fullFile": "C:\\projects\\github-stott\\odata-v4-parser\\test\\parser.spec.js",
        "file": "\\test\\parser.spec.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "should instantiate odata parser",
            "fullTitle": "Parser should instantiate odata parser",
            "timedOut": false,
            "duration": 8,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "var parser = new Parser();\nvar ast = parser.filter(\"Categories/all(d:d/Title eq 'alma')\");\nexpect(\n  ast.value.value.value.value.next.value.value.predicate.value.value.right\n    .value\n).to.equal(\"Edm.String\");",
            "err": {},
            "isRoot": false,
            "uuid": "1a446d44-4862-4fba-8336-3ba509f7e146",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should parse query string",
            "fullTitle": "Parser should parse query string",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "var parser = new Parser();\nvar ast = parser.query(\"$filter=Title eq 'alma'\");\nexpect(ast.value.options[0].type).to.equal(\"Filter\");",
            "err": {},
            "isRoot": false,
            "uuid": "705743c5-f74a-469c-9c33-8cf695ab1f24",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should parse multiple orderby params",
            "fullTitle": "Parser should parse multiple orderby params",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "var parser = new Parser();\nvar ast = parser.query(\"$orderby=foo,bar\");\nexpect(ast.value.options[0].value.items[0].raw).to.equal(\"foo\");\nexpect(ast.value.options[0].value.items[1].raw).to.equal(\"bar\");",
            "err": {},
            "isRoot": false,
            "uuid": "b1253f8e-6e0b-4b91-baff-b343325ebd8b",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should parse custom query options",
            "fullTitle": "Parser should parse custom query options",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "var parser = new Parser();\nvar ast = parser.query(\"foo=123&bar=foobar\");\nexpect(ast.value.options[0].value.key).to.equal(\"foo\");\nexpect(ast.value.options[0].value.value).to.equal(\"123\");\nexpect(ast.value.options[1].value.key).to.equal(\"bar\");\nexpect(ast.value.options[1].value.value).to.equal(\"foobar\");",
            "err": {},
            "isRoot": false,
            "uuid": "57d1a545-1067-492a-8ceb-97d71526b607",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "should throw error parsing invalid custom query options",
            "fullTitle": "Parser should throw error parsing invalid custom query options",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "var parser = new Parser();\nvar error = false;\ntry{\n  var ast = parser.query(\"$foo=123\");\n  error = true;\n}catch(err){}\nexpect(error).to.be.false;",
            "err": {},
            "isRoot": false,
            "uuid": "b7559a8c-2498-4c5c-a307-a710edf57b4c",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "1a446d44-4862-4fba-8336-3ba509f7e146",
          "705743c5-f74a-469c-9c33-8cf695ab1f24",
          "b1253f8e-6e0b-4b91-baff-b343325ebd8b",
          "57d1a545-1067-492a-8ceb-97d71526b607",
          "b7559a8c-2498-4c5c-a307-a710edf57b4c"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 12,
        "root": false,
        "rootEmpty": false,
        "_timeout": 2000
      },
      {
        "uuid": "2c70fd16-90b0-46cd-9aa2-31964fa79f25",
        "title": "Primitive literals from json",
        "fullFile": "C:\\projects\\github-stott\\odata-v4-parser\\test\\primitiveLiteral.spec.js",
        "file": "\\test\\primitiveLiteral.spec.js",
        "beforeHooks": [],
        "afterHooks": [],
        "tests": [
          {
            "title": "#0 should parse Binary with X: X'1a2B3c4D'",
            "fullTitle": "Primitive literals from json #0 should parse Binary with X: X'1a2B3c4D'",
            "timedOut": false,
            "duration": 3,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "31d0ba7a-6a42-4c62-b056-3b80f55c550f",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#1 should parse Binary - empty: binary''",
            "fullTitle": "Primitive literals from json #1 should parse Binary - empty: binary''",
            "timedOut": false,
            "duration": 2,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "bc713abe-c5ad-4df0-bd3a-eadefde34c97",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#2 should parse Binary - f: binary'Zg=='",
            "fullTitle": "Primitive literals from json #2 should parse Binary - f: binary'Zg=='",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "b03f9875-88bd-4345-8f17-f66452514e3e",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#3 should parse Binary - f (pad character is optional): binary'Zg'",
            "fullTitle": "Primitive literals from json #3 should parse Binary - f (pad character is optional): binary'Zg'",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d7a11eba-3771-4077-9ec3-d10f27b61ff6",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#4 should parse Binary - fo: binary'Zm8='",
            "fullTitle": "Primitive literals from json #4 should parse Binary - fo: binary'Zm8='",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "20d7af36-6ffd-4c09-9a4f-5c77ec647b64",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#5 should parse Binary - fo (pad character is optional): binary'Zm8='",
            "fullTitle": "Primitive literals from json #5 should parse Binary - fo (pad character is optional): binary'Zm8='",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d4b14e5a-4d5c-427e-bb3b-fd5a937d89de",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#6 should parse Binary - foo: binary'Zm9v'",
            "fullTitle": "Primitive literals from json #6 should parse Binary - foo: binary'Zm9v'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "cbc705bc-203b-4292-ad6f-4709fd7d259f",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#7 should parse Binary - foob: binary'Zm9vYg=='",
            "fullTitle": "Primitive literals from json #7 should parse Binary - foob: binary'Zm9vYg=='",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "1ecc7b80-07ff-441c-b7fb-16205c639883",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#8 should parse Binary - fooba: binary'Zm9vYmE='",
            "fullTitle": "Primitive literals from json #8 should parse Binary - fooba: binary'Zm9vYmE='",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "3c8c7a6f-c2ab-4b6b-a300-3f75dc897799",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#9 should parse Binary - foobar: binary'Zm9vYmFy'",
            "fullTitle": "Primitive literals from json #9 should parse Binary - foobar: binary'Zm9vYmFy'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "bff652f9-6b92-4261-b106-b21270d1cd5a",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#10 should parse Date in URL or body: 2012-09-03",
            "fullTitle": "Primitive literals from json #10 should parse Date in URL or body: 2012-09-03",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d1330f86-fe44-4429-ad5b-cb7dab90d74a",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#11 should parse Date: 2012-09-10",
            "fullTitle": "Primitive literals from json #11 should parse Date: 2012-09-10",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "84e81244-c522-41bd-a68f-e95915e0774a",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#12 should parse Date: 2012-09-20",
            "fullTitle": "Primitive literals from json #12 should parse Date: 2012-09-20",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "510f97b4-e77b-46ec-bc34-8d47cbbf236d",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#13 should parse Date: 2012-09-03",
            "fullTitle": "Primitive literals from json #13 should parse Date: 2012-09-03",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d1abe440-0253-4195-9c4c-1198388c9a8a",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#14 should parse Date: year zero: 0000-01-01",
            "fullTitle": "Primitive literals from json #14 should parse Date: year zero: 0000-01-01",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d50a4f71-a82a-485a-b5d4-46c9a64a59b8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#15 should parse Date: negative: -10000-04-01",
            "fullTitle": "Primitive literals from json #15 should parse Date: negative: -10000-04-01",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "b137dd67-eb80-4fd6-aa64-73c73a728fe2",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#16 should parse DateTimeOffset: no seconds: 2012-09-03T13:52Z",
            "fullTitle": "Primitive literals from json #16 should parse DateTimeOffset: no seconds: 2012-09-03T13:52Z",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "56af2f9b-9281-4425-b53b-1f3322305b13",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#17 should parse DateTimeOffset: seconds: 2012-09-03T08:09:02Z",
            "fullTitle": "Primitive literals from json #17 should parse DateTimeOffset: seconds: 2012-09-03T08:09:02Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "f5f27a76-ac65-427f-912a-a1d0bc16eccd",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#18 should parse DateTimeOffset: subseconds: 2012-08-31T18:19:22.1Z",
            "fullTitle": "Primitive literals from json #18 should parse DateTimeOffset: subseconds: 2012-08-31T18:19:22.1Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "b6e379c4-abbf-42ad-9603-6177b29b5dc6",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#19 should parse DateTimeOffset: year zero: 0000-01-01T00:00Z",
            "fullTitle": "Primitive literals from json #19 should parse DateTimeOffset: year zero: 0000-01-01T00:00Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "d59c9ec2-c428-4c3f-b841-6533ed0a65e5",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#20 should parse DateTimeOffset: negative: -10000-04-01T00:00Z",
            "fullTitle": "Primitive literals from json #20 should parse DateTimeOffset: negative: -10000-04-01T00:00Z",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "e9edebe0-ae46-4b5e-abc1-8daa0145b389",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#21 should parse DateTimeOffset: Midnight this day: 2011-12-31T24:00Z",
            "fullTitle": "Primitive literals from json #21 should parse DateTimeOffset: Midnight this day: 2011-12-31T24:00Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "191b6b39-6f15-4a2a-9d06-5d1788733d3d",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#22 should parse DateTimeOffset: Midnight this day with seconds: 2011-12-31T24:00:00Z",
            "fullTitle": "Primitive literals from json #22 should parse DateTimeOffset: Midnight this day with seconds: 2011-12-31T24:00:00Z",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "5776a12a-e53b-4a77-a9ec-de4e6429f8b0",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#23 should parse DateTimeOffset: CEST: 2012-09-03T14:53+02:00",
            "fullTitle": "Primitive literals from json #23 should parse DateTimeOffset: CEST: 2012-09-03T14:53+02:00",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "4a377f81-ea2e-4fc4-b1d0-d7dc196a2805",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#24 should parse DateTimeOffset: UTC: 2012-09-03T12:53Z",
            "fullTitle": "Primitive literals from json #24 should parse DateTimeOffset: UTC: 2012-09-03T12:53Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "e705948b-6ac8-427f-8b05-8f3a490eb0ae",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#25 should parse DateTimeOffset: 24:00: 2012-09-03T24:00-03:00",
            "fullTitle": "Primitive literals from json #25 should parse DateTimeOffset: 24:00: 2012-09-03T24:00-03:00",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "54f8521d-620d-4356-94ee-d2c0bf63fdcf",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#26 should parse DateTimeOffset: 20th hour UTC: 2012-11-28T20:00:00.000Z",
            "fullTitle": "Primitive literals from json #26 should parse DateTimeOffset: 20th hour UTC: 2012-11-28T20:00:00.000Z",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "e763b90a-130d-4a4a-9b48-be163e497e38",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#27 should parse Decimal: 3.14",
            "fullTitle": "Primitive literals from json #27 should parse Decimal: 3.14",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "41ce1176-6004-4721-b0c5-85f0e103ffac",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#28 should parse Duration in body: P6DT23H59M59.9999S",
            "fullTitle": "Primitive literals from json #28 should parse Duration in body: P6DT23H59M59.9999S",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "722d8da2-c6b7-4e5c-8fb2-7fa5d5d1ebdd",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#29 should parse Duration in body: no years allowed: P1Y6DT23H59M59.9999S",
            "fullTitle": "Primitive literals from json #29 should parse Duration in body: no years allowed: P1Y6DT23H59M59.9999S",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "147408c8-9b08-4fe0-b974-42ab2e45c809",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#30 should parse Duration in body: no months allowed: P1M6DT23H59M59.9999S",
            "fullTitle": "Primitive literals from json #30 should parse Duration in body: no months allowed: P1M6DT23H59M59.9999S",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "922d346d-50bb-4c7e-a707-0b2b71c97ae1",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#31 should parse Duration in URL: duration'P6DT23H59M59.9999S'",
            "fullTitle": "Primitive literals from json #31 should parse Duration in URL: duration'P6DT23H59M59.9999S'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "a70b2e05-cff3-4c1c-b5bc-d310e25f0f9b",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#32 should parse Decimal: integer: -2",
            "fullTitle": "Primitive literals from json #32 should parse Decimal: integer: -2",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "20126fd0-48e9-48e0-9b32-cb0f87cc5027",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#33 should parse Decimal: integer: +42.",
            "fullTitle": "Primitive literals from json #33 should parse Decimal: integer: +42.",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "f128c1d1-75c5-4a2a-9eca-54158d3887fd",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#34 should parse Decimal: no digit before decimal point: .1",
            "fullTitle": "Primitive literals from json #34 should parse Decimal: no digit before decimal point: .1",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "b260f9ee-5175-4121-977d-94e4e8690d96",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#35 should parse Decimal in URL: 3.14",
            "fullTitle": "Primitive literals from json #35 should parse Decimal in URL: 3.14",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "8a02ac4c-aaf8-4099-81ff-c3d3af7a42b4",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#36 should parse Double: 3.14",
            "fullTitle": "Primitive literals from json #36 should parse Double: 3.14",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "6f0f2ee2-3c99-453a-826a-592dc1989ac7",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#37 should parse Double with exponent: -0.314e1",
            "fullTitle": "Primitive literals from json #37 should parse Double with exponent: -0.314e1",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "4e6ca102-b94f-45ad-bdba-ea79eea74827",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#38 should parse Negative infinity: -INF",
            "fullTitle": "Primitive literals from json #38 should parse Negative infinity: -INF",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "47129f68-c77f-4a9d-844e-354441dd1e45",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#39 should parse Positive infinity: INF",
            "fullTitle": "Primitive literals from json #39 should parse Positive infinity: INF",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "76a1a704-d08a-40f3-a233-edfa67b02319",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#40 should parse Not a Number: NaN",
            "fullTitle": "Primitive literals from json #40 should parse Not a Number: NaN",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "f752fc70-4c01-4a32-8152-e6b2c44baee0",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#41 should parse Double in URL: -0.314e1",
            "fullTitle": "Primitive literals from json #41 should parse Double in URL: -0.314e1",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "6b44558c-9b6c-4b64-90c6-40d1a39b27c7",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#42 should parse Single in URL: -0.314e1",
            "fullTitle": "Primitive literals from json #42 should parse Single in URL: -0.314e1",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "0584c438-1301-4c85-9a2e-5a8c8a221533",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#43 should parse Byte: 255",
            "fullTitle": "Primitive literals from json #43 should parse Byte: 255",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "0d784ae9-643e-4106-83de-160923fb8f14",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#44 should parse SByte: -128",
            "fullTitle": "Primitive literals from json #44 should parse SByte: -128",
            "timedOut": false,
            "duration": 2,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "8f48eb13-423e-4266-87aa-781e5ef1fbee",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#45 should parse Int16: +32000",
            "fullTitle": "Primitive literals from json #45 should parse Int16: +32000",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "5ef608cb-6fda-4399-8032-bef5e63030eb",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#46 should parse Int32: -2000000000",
            "fullTitle": "Primitive literals from json #46 should parse Int32: -2000000000",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "f5f552d5-f6fc-45a9-a7a7-b5388043d2f5",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#47 should parse Int64: 1234567890123456789",
            "fullTitle": "Primitive literals from json #47 should parse Int64: 1234567890123456789",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "04dc30f1-b5a3-4c65-bae4-b80781e8b810",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#48 should parse Null: unqualified: null",
            "fullTitle": "Primitive literals from json #48 should parse Null: unqualified: null",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "4bc9a8c5-be80-4027-85c2-1a552423a49d",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#49 should parse String: 'ABCDEFGHIHJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&('')*+,;=@'",
            "fullTitle": "Primitive literals from json #49 should parse String: 'ABCDEFGHIHJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~!$&('')*+,;=@'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "0872c5bd-b656-4c83-a8d0-fb02da08a712",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#50 should parse String: 'O''Neil'",
            "fullTitle": "Primitive literals from json #50 should parse String: 'O''Neil'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "586d4d37-c442-4e0b-bbf5-6b32637c7cd8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#51 should parse String: %27O'%27Neil'",
            "fullTitle": "Primitive literals from json #51 should parse String: %27O'%27Neil'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "fcd078d8-89fb-49e1-acea-786eb5bb8775",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#52 should parse String: 'O'Neil'",
            "fullTitle": "Primitive literals from json #52 should parse String: 'O'Neil'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "99a5dd9f-0c9e-40d0-8d03-931072581ba2",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#53 should parse String: 'O%27Neil'",
            "fullTitle": "Primitive literals from json #53 should parse String: 'O%27Neil'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "7059f963-0e09-40ec-8787-a29b2f894641",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#54 should parse String: '%26%28'",
            "fullTitle": "Primitive literals from json #54 should parse String: '%26%28'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "7fafa3ca-9aed-42ea-8031-1c6d1f99bad5",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#55 should parse primitive value in request body - enumeration member: Yellow",
            "fullTitle": "Primitive literals from json #55 should parse primitive value in request body - enumeration member: Yellow",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "4982da26-ac61-4ab8-be86-7e7fc7149129",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#56 should parse primitive value in request body - geo point: SRID=0;Point(142.1 64.1)",
            "fullTitle": "Primitive literals from json #56 should parse primitive value in request body - geo point: SRID=0;Point(142.1 64.1)",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "24536bfa-5316-4a92-a5cd-3d1879ac68fe",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#57 should parse primitive value in request body - integer: 0123456789",
            "fullTitle": "Primitive literals from json #57 should parse primitive value in request body - integer: 0123456789",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "efd7682b-4afb-4446-b4c2-8decc77621c9",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#58 should parse primitive value in request body - guid: 01234567-89ab-cdef-0123-456789abcdef",
            "fullTitle": "Primitive literals from json #58 should parse primitive value in request body - guid: 01234567-89ab-cdef-0123-456789abcdef",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "f0640046-d30a-49c7-b9e2-54351a9fe564",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#59 should parse primitive value in request body - binary: a123456789abcdefABA=",
            "fullTitle": "Primitive literals from json #59 should parse primitive value in request body - binary: a123456789abcdefABA=",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "0696da67-8eeb-44e7-a59c-55a64927eae0",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#60 should parse primitive value in request body - binary with line breaks and spaces: a1234567 89abcdefABA",
            "fullTitle": "Primitive literals from json #60 should parse primitive value in request body - binary with line breaks and spaces: a1234567 89abcdefABA",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "47e784dc-936c-472b-937f-caf31109939b",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#61 should parse Key: 'Hugo''s%20Tavern'",
            "fullTitle": "Primitive literals from json #61 should parse Key: 'Hugo''s%20Tavern'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "78d35131-7a67-4b71-8ffe-ae36850eabb6",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#62 should parse Correct Guid: 01234567-89ab-cdef-0123-456789abcdef",
            "fullTitle": "Primitive literals from json #62 should parse Correct Guid: 01234567-89ab-cdef-0123-456789abcdef",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "30eb4ef3-ee6f-4491-aeb8-9d2fffd1abee",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#63 should parse Guid with wrong character: 01234g67-89ab-cdef-0123-456789abcdef",
            "fullTitle": "Primitive literals from json #63 should parse Guid with wrong character: 01234g67-89ab-cdef-0123-456789abcdef",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "60978ddb-485a-4c36-a17b-11691dd24581",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#64 should parse Guid with less than 32 digits: 01234567-89ab-cdef-456789abcdef",
            "fullTitle": "Primitive literals from json #64 should parse Guid with less than 32 digits: 01234567-89ab-cdef-456789abcdef",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "9f0f11d9-0316-461b-a8e1-a0a021ef9b58",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#65 should parse TimeOfDay: 11:22:33",
            "fullTitle": "Primitive literals from json #65 should parse TimeOfDay: 11:22:33",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "2aa989ce-2dae-4cca-b9d9-6b7122ad4eb1",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#66 should parse TimeOfDay: no seconds: 11:22",
            "fullTitle": "Primitive literals from json #66 should parse TimeOfDay: no seconds: 11:22",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "c49ad18f-b17a-4af8-8fb4-13a4847e1fe3",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#67 should parse TimeOfDay: fractional seconds: 11:22:33.4444444",
            "fullTitle": "Primitive literals from json #67 should parse TimeOfDay: fractional seconds: 11:22:33.4444444",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "81776020-b9e4-4d83-aa9c-c3a95988bcc8",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#68 should parse TimeOfDay: 24:00: 24:00:00",
            "fullTitle": "Primitive literals from json #68 should parse TimeOfDay: 24:00: 24:00:00",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "42c236c2-8ea8-4651-93bb-7acd2a1b2acb",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#69 should parse 5.1.1.1.1 boolean - only true and false: 0",
            "fullTitle": "Primitive literals from json #69 should parse 5.1.1.1.1 boolean - only true and false: 0",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "37465e00-8f84-4c7b-b104-feb2e53138e9",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#70 should parse 5.1.1.1.1 boolean - only true and false: 1",
            "fullTitle": "Primitive literals from json #70 should parse 5.1.1.1.1 boolean - only true and false: 1",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "94aace65-18fa-4fae-9884-10a8ad292347",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#71 should parse GeographyCollection: geography'SRID=0;Collection(LineString(142.1 64.1,3.14 2.78))'",
            "fullTitle": "Primitive literals from json #71 should parse GeographyCollection: geography'SRID=0;Collection(LineString(142.1 64.1,3.14 2.78))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "bd18ef42-df79-4dc3-88fe-90d5f82519a9",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#72 should parse GeographyLineString: geography'SRID=0;LineString(142.1 64.1,3.14 2.78)'",
            "fullTitle": "Primitive literals from json #72 should parse GeographyLineString: geography'SRID=0;LineString(142.1 64.1,3.14 2.78)'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "fb50cd8a-288e-4a69-9f98-1b4d3144c833",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#73 should parse GeographyMultiLineString: geography'SRID=0;MultiLineString((142.1 64.1,3.14 2.78),(142.1 64.1,3.14 2.78))'",
            "fullTitle": "Primitive literals from json #73 should parse GeographyMultiLineString: geography'SRID=0;MultiLineString((142.1 64.1,3.14 2.78),(142.1 64.1,3.14 2.78))'",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "35863bf2-b8c8-4761-9676-50e5c0212fde",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#74 should parse GeographyMultiPoint: geography'SRID=0;MultiPoint()'",
            "fullTitle": "Primitive literals from json #74 should parse GeographyMultiPoint: geography'SRID=0;MultiPoint()'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "a58c36d6-3e10-486c-9408-00d872a840a6",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#75 should parse GeographyMultiPoint: geography'SRID=0;MultiPoint((142.1 64.1),(1 2))'",
            "fullTitle": "Primitive literals from json #75 should parse GeographyMultiPoint: geography'SRID=0;MultiPoint((142.1 64.1),(1 2))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "24bed505-ca95-4f80-bb6f-0daf355db5ab",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#76 should parse GeographyMultiPolygon: geography'SRID=0;MultiPolygon(((1 1,1 1),(1 1,2 2,3 3,1 1)))'",
            "fullTitle": "Primitive literals from json #76 should parse GeographyMultiPolygon: geography'SRID=0;MultiPolygon(((1 1,1 1),(1 1,2 2,3 3,1 1)))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "50d142f7-e9f7-4ef2-a79a-5e18195f8ad5",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#77 should parse GeographyPoint: geography'SRID=0;Point(142.1 64.1)'",
            "fullTitle": "Primitive literals from json #77 should parse GeographyPoint: geography'SRID=0;Point(142.1 64.1)'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "cd84e140-a10b-4878-af13-9a29c39fb5e2",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#78 should parse GeographyPolygon: geography'SRID=0;Polygon((1 1,1 1),(1 1,2 2,3 3,1 1))'",
            "fullTitle": "Primitive literals from json #78 should parse GeographyPolygon: geography'SRID=0;Polygon((1 1,1 1),(1 1,2 2,3 3,1 1))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "0531d1ef-c8cf-4693-ac31-c5705d94c1a6",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#79 should parse GeometryCollection: geometry'SRID=0;Collection(LineString(142.1 64.1,3.14 2.78))'",
            "fullTitle": "Primitive literals from json #79 should parse GeometryCollection: geometry'SRID=0;Collection(LineString(142.1 64.1,3.14 2.78))'",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "543302cc-d0ff-4d2f-94a7-dc7cdbabca06",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#80 should parse GeometryLineString: geometry'SRID=0;LineString(142.1 64.1,3.14 2.78)'",
            "fullTitle": "Primitive literals from json #80 should parse GeometryLineString: geometry'SRID=0;LineString(142.1 64.1,3.14 2.78)'",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "3fcce38a-391c-4864-94ac-54053093725c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#81 should parse GeometryMultiLineString: geometry'SRID=0;MultiLineString((142.1 64.1,3.14 2.78),(142.1 64.1,3.14 2.78))'",
            "fullTitle": "Primitive literals from json #81 should parse GeometryMultiLineString: geometry'SRID=0;MultiLineString((142.1 64.1,3.14 2.78),(142.1 64.1,3.14 2.78))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "a5bf5b3e-5f90-48e5-b1be-c38aab131c36",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#82 should parse GeometryMultiPoint: geometry'SRID=0;MultiPoint()'",
            "fullTitle": "Primitive literals from json #82 should parse GeometryMultiPoint: geometry'SRID=0;MultiPoint()'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "45796da1-b816-4709-b13d-79f7d268b051",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#83 should parse GeometryMultiPoint: geometry'SRID=0;MultiPoint((142.1 64.1),(1 2))'",
            "fullTitle": "Primitive literals from json #83 should parse GeometryMultiPoint: geometry'SRID=0;MultiPoint((142.1 64.1),(1 2))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "fd069ab7-4aee-4ddd-9afe-def01519081c",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#84 should parse GeometryMultiPolygon: geometry'SRID=0;MultiPolygon(((1 1,1 1),(1 1,2 2,3 3,1 1)))'",
            "fullTitle": "Primitive literals from json #84 should parse GeometryMultiPolygon: geometry'SRID=0;MultiPolygon(((1 1,1 1),(1 1,2 2,3 3,1 1)))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "c29b3688-17dd-4b45-a115-8537e51ef8d0",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#85 should parse GeometryPoint: geometry'SRID=0;Point(142.1 64.1)'",
            "fullTitle": "Primitive literals from json #85 should parse GeometryPoint: geometry'SRID=0;Point(142.1 64.1)'",
            "timedOut": false,
            "duration": 1,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "46ae3cf2-9ef4-4278-bd1a-4ebba5bfac17",
            "isHook": false,
            "skipped": false
          },
          {
            "title": "#86 should parse GeometryPolygon: geometry'SRID=0;Polygon((1 1,1 1),(1 1,2 2,3 3,1 1))'",
            "fullTitle": "Primitive literals from json #86 should parse GeometryPolygon: geometry'SRID=0;Polygon((1 1,1 1),(1 1,2 2,3 3,1 1))'",
            "timedOut": false,
            "duration": 0,
            "state": "passed",
            "speed": "fast",
            "pass": true,
            "fail": false,
            "pending": false,
            "code": "let source = new Uint8Array(new Buffer(item.Input));\nif (item[resultName].next === undefined) item[resultName].next = item.Input.length;\nif (item[resultName].raw === undefined) item[resultName].raw = item.Input;\nlet literalFunctionName = getLiteralFunctionName(item[\"-Rule\"] || 'primitiveLiteral');\nlet literal = (PrimitiveLiteral[literalFunctionName] || PrimitiveLiteral.primitiveLiteral)(source, 0);\nif (item['-FailAt'] !== undefined) {\n  expect(literal).to.be.undefined;\n  return;\n}\nexpect(literal).to.deep.equal(item[resultName]);",
            "err": {},
            "isRoot": false,
            "uuid": "051f3c52-3724-47b5-a410-d8569f672516",
            "isHook": false,
            "skipped": false
          }
        ],
        "suites": [],
        "passes": [
          "31d0ba7a-6a42-4c62-b056-3b80f55c550f",
          "bc713abe-c5ad-4df0-bd3a-eadefde34c97",
          "b03f9875-88bd-4345-8f17-f66452514e3e",
          "d7a11eba-3771-4077-9ec3-d10f27b61ff6",
          "20d7af36-6ffd-4c09-9a4f-5c77ec647b64",
          "d4b14e5a-4d5c-427e-bb3b-fd5a937d89de",
          "cbc705bc-203b-4292-ad6f-4709fd7d259f",
          "1ecc7b80-07ff-441c-b7fb-16205c639883",
          "3c8c7a6f-c2ab-4b6b-a300-3f75dc897799",
          "bff652f9-6b92-4261-b106-b21270d1cd5a",
          "d1330f86-fe44-4429-ad5b-cb7dab90d74a",
          "84e81244-c522-41bd-a68f-e95915e0774a",
          "510f97b4-e77b-46ec-bc34-8d47cbbf236d",
          "d1abe440-0253-4195-9c4c-1198388c9a8a",
          "d50a4f71-a82a-485a-b5d4-46c9a64a59b8",
          "b137dd67-eb80-4fd6-aa64-73c73a728fe2",
          "56af2f9b-9281-4425-b53b-1f3322305b13",
          "f5f27a76-ac65-427f-912a-a1d0bc16eccd",
          "b6e379c4-abbf-42ad-9603-6177b29b5dc6",
          "d59c9ec2-c428-4c3f-b841-6533ed0a65e5",
          "e9edebe0-ae46-4b5e-abc1-8daa0145b389",
          "191b6b39-6f15-4a2a-9d06-5d1788733d3d",
          "5776a12a-e53b-4a77-a9ec-de4e6429f8b0",
          "4a377f81-ea2e-4fc4-b1d0-d7dc196a2805",
          "e705948b-6ac8-427f-8b05-8f3a490eb0ae",
          "54f8521d-620d-4356-94ee-d2c0bf63fdcf",
          "e763b90a-130d-4a4a-9b48-be163e497e38",
          "41ce1176-6004-4721-b0c5-85f0e103ffac",
          "722d8da2-c6b7-4e5c-8fb2-7fa5d5d1ebdd",
          "147408c8-9b08-4fe0-b974-42ab2e45c809",
          "922d346d-50bb-4c7e-a707-0b2b71c97ae1",
          "a70b2e05-cff3-4c1c-b5bc-d310e25f0f9b",
          "20126fd0-48e9-48e0-9b32-cb0f87cc5027",
          "f128c1d1-75c5-4a2a-9eca-54158d3887fd",
          "b260f9ee-5175-4121-977d-94e4e8690d96",
          "8a02ac4c-aaf8-4099-81ff-c3d3af7a42b4",
          "6f0f2ee2-3c99-453a-826a-592dc1989ac7",
          "4e6ca102-b94f-45ad-bdba-ea79eea74827",
          "47129f68-c77f-4a9d-844e-354441dd1e45",
          "76a1a704-d08a-40f3-a233-edfa67b02319",
          "f752fc70-4c01-4a32-8152-e6b2c44baee0",
          "6b44558c-9b6c-4b64-90c6-40d1a39b27c7",
          "0584c438-1301-4c85-9a2e-5a8c8a221533",
          "0d784ae9-643e-4106-83de-160923fb8f14",
          "8f48eb13-423e-4266-87aa-781e5ef1fbee",
          "5ef608cb-6fda-4399-8032-bef5e63030eb",
          "f5f552d5-f6fc-45a9-a7a7-b5388043d2f5",
          "04dc30f1-b5a3-4c65-bae4-b80781e8b810",
          "4bc9a8c5-be80-4027-85c2-1a552423a49d",
          "0872c5bd-b656-4c83-a8d0-fb02da08a712",
          "586d4d37-c442-4e0b-bbf5-6b32637c7cd8",
          "fcd078d8-89fb-49e1-acea-786eb5bb8775",
          "99a5dd9f-0c9e-40d0-8d03-931072581ba2",
          "7059f963-0e09-40ec-8787-a29b2f894641",
          "7fafa3ca-9aed-42ea-8031-1c6d1f99bad5",
          "4982da26-ac61-4ab8-be86-7e7fc7149129",
          "24536bfa-5316-4a92-a5cd-3d1879ac68fe",
          "efd7682b-4afb-4446-b4c2-8decc77621c9",
          "f0640046-d30a-49c7-b9e2-54351a9fe564",
          "0696da67-8eeb-44e7-a59c-55a64927eae0",
          "47e784dc-936c-472b-937f-caf31109939b",
          "78d35131-7a67-4b71-8ffe-ae36850eabb6",
          "30eb4ef3-ee6f-4491-aeb8-9d2fffd1abee",
          "60978ddb-485a-4c36-a17b-11691dd24581",
          "9f0f11d9-0316-461b-a8e1-a0a021ef9b58",
          "2aa989ce-2dae-4cca-b9d9-6b7122ad4eb1",
          "c49ad18f-b17a-4af8-8fb4-13a4847e1fe3",
          "81776020-b9e4-4d83-aa9c-c3a95988bcc8",
          "42c236c2-8ea8-4651-93bb-7acd2a1b2acb",
          "37465e00-8f84-4c7b-b104-feb2e53138e9",
          "94aace65-18fa-4fae-9884-10a8ad292347",
          "bd18ef42-df79-4dc3-88fe-90d5f82519a9",
          "fb50cd8a-288e-4a69-9f98-1b4d3144c833",
          "35863bf2-b8c8-4761-9676-50e5c0212fde",
          "a58c36d6-3e10-486c-9408-00d872a840a6",
          "24bed505-ca95-4f80-bb6f-0daf355db5ab",
          "50d142f7-e9f7-4ef2-a79a-5e18195f8ad5",
          "cd84e140-a10b-4878-af13-9a29c39fb5e2",
          "0531d1ef-c8cf-4693-ac31-c5705d94c1a6",
          "543302cc-d0ff-4d2f-94a7-dc7cdbabca06",
          "3fcce38a-391c-4864-94ac-54053093725c",
          "a5bf5b3e-5f90-48e5-b1be-c38aab131c36",
          "45796da1-b816-4709-b13d-79f7d268b051",
          "fd069ab7-4aee-4ddd-9afe-def01519081c",
          "c29b3688-17dd-4b45-a115-8537e51ef8d0",
          "46ae3cf2-9ef4-4278-bd1a-4ebba5bfac17",
          "051f3c52-3724-47b5-a410-d8569f672516"
        ],
        "failures": [],
        "pending": [],
        "skipped": [],
        "duration": 19,
        "root": false,
        "rootEmpty": false,
        "_timeout": 2000
      }
    ],
    "passes": [],
    "failures": [],
    "pending": [],
    "skipped": [],
    "duration": 0,
    "root": true,
    "rootEmpty": true,
    "_timeout": 2000
  },
  "copyrightYear": 2020
}